{"version":3,"file":"static/js/484.9aa7f76f.chunk.js","mappings":"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","sources":["pages/demo2/drawSea.ts","utils/distance.ts","pages/demo2/index.tsx"],"sourcesContent":["import { getDistance } from \"../../utils/distance\";\n\nconst radius = 2, // 粒子半径大小\n  repelRadius = 100, // 排斥圈半径\n  speed = [0.01, 0.1], // 排斥速度\n  gridWith = 30; // 粒子间距\n\nconst particleSea: Point[] = [],\n  defaultSea: Point[] = [];\nfor (let i = radius; i < window.innerWidth; i += gridWith) {\n  for (let j = radius; j < window.innerHeight; j += gridWith) {\n    particleSea.push([i, j]);\n    defaultSea.push([i, j]);\n  }\n}\n\nconst drawPoint = (ctx: CanvasRenderingContext2D, point: Point) => {\n  ctx.beginPath();\n  ctx.arc(point[0], point[1], radius, 0, 2 * Math.PI);\n  ctx.fillStyle = \"#666\";\n  ctx.fill();\n  ctx.closePath();\n};\n\nconst clearPoint = (ctx: CanvasRenderingContext2D, point: Point) => {\n  ctx.beginPath();\n  ctx.arc(point[0], point[1], radius + 1, 0, 2 * Math.PI);\n  ctx.fillStyle = \"#000\";\n  ctx.fill();\n  ctx.closePath();\n};\n\nconst movePoint = (target: Point, p: Point, i: number) => {\n  const distance = getDistance(target, p);\n\n  // 防止边缘抖动，设置一定阈值，应该怎么计算目前不知道，试出来的\n  if (distance - repelRadius < 15) {\n    const k = (target[1] - p[1]) / (target[0] - p[0]);\n    const angle = Math.atan(k);\n    const s = speed[1] - ((speed[1] - speed[0]) * distance) / repelRadius;\n    const diff = target[0] - p[0] > 0 ? -distance * s : distance * s;\n    const dX = diff * Math.cos(angle);\n    const dY = diff * Math.sin(angle);\n    particleSea[i] = [p[0] + dX, p[1] + dY];\n  } else {\n    const d = defaultSea[i];\n    if (p[0] !== d[0] || p[1] !== d[1]) {\n      const awayDistance = getDistance(d, p);\n\n      const k = (d[1] - p[1]) / (d[0] - p[0]);\n      const angle = Math.atan(k);\n      const s = speed[0] + ((speed[1] - speed[0]) * awayDistance) / repelRadius;\n      const diff = d[0] - p[0] > 0 ? awayDistance * s : -awayDistance * s;\n      const dX = diff * Math.cos(angle);\n      const dY = diff * Math.sin(angle);\n      particleSea[i] = [p[0] + dX, p[1] + dY];\n    }\n  }\n};\n\nexport const drawRepelPoint = (ctx: CanvasRenderingContext2D, point: Point) => {\n  const temp = [...particleSea];\n\n  particleSea.forEach((p, i) => {\n    movePoint(point, p, i);\n  });\n\n  particleSea.forEach(([x, y], i) => {\n    const [m, n] = temp[i];\n    if (x !== m || y !== n) {\n      clearPoint(ctx, [m, n]);\n      drawPoint(ctx, [x, y]);\n    }\n  });\n};\n\nlet task: number;\nexport const drawRepel = (ctx: CanvasRenderingContext2D, point: Point) => {\n  drawRepelPoint(ctx, point);\n  cancelAnimationFrame(task);\n\n  task = requestAnimationFrame(() => {\n    drawRepel(ctx, point);\n  });\n};\n\nexport const drawSea = (ctx: CanvasRenderingContext2D) => {\n  defaultSea.forEach((point) => drawPoint(ctx, point));\n};\n","export const getDistance = (p1: Point, p2: Point) => {\n  const offsetX = Math.abs(p1[0] - p2[0]),\n    offsetY = Math.abs(p1[1] - p2[1]);\n  return Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n};","import { memo, useEffect, useRef } from \"react\";\n\nimport { drawRepel, drawSea } from \"./drawSea\";\n\nexport default memo(() => {\n  const ref = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    if (ref.current) {\n      const ctx = ref.current.getContext(\"2d\");\n\n      ctx && drawSea(ctx);\n\n      let isStart = false;\n\n      const onStart = (p: Point) => {\n        isStart = true;\n        ctx && drawRepel(ctx, p);\n      };\n\n      const onEnd = () => {\n        isStart = false;\n        ctx && drawRepel(ctx, [Infinity, Infinity]);\n      };\n\n      const draw = (p: Point) => {\n        if (isStart && ctx) {\n          drawRepel(ctx, p);\n        }\n      };\n\n      const touchStart = (e: TouchEvent) => {\n        e.preventDefault();\n        onStart([e.targetTouches[0].clientX, e.targetTouches[0].clientY]);\n      };\n\n      const mouseStart = (e: MouseEvent) => {\n        onStart([e.clientX, e.clientY]);\n      };\n\n      const touchMove = (e: TouchEvent) => {\n        e.preventDefault();\n        draw([e.targetTouches[0].clientX, e.targetTouches[0].clientY]);\n      };\n\n      const mouseMove = (e: MouseEvent) => {\n        draw([e.clientX, e.clientY]);\n      };\n\n      document.addEventListener(\"touchstart\", touchStart, { passive: false });\n      document.addEventListener(\"touchmove\", touchMove, { passive: false });\n      document.addEventListener(\"touchend\", onEnd);\n      document.addEventListener(\"mousedown\", mouseStart);\n      document.addEventListener(\"mouseup\", onEnd);\n      document.addEventListener(\"mousemove\", mouseMove);\n      document.addEventListener(\"contextmenu\", onEnd);\n\n      return () => {\n        document.removeEventListener(\"touchstart\", touchStart);\n        document.removeEventListener(\"touchmove\", touchMove);\n        document.removeEventListener(\"touchend\", onEnd);\n        document.removeEventListener(\"mousedown\", mouseStart);\n        document.removeEventListener(\"mouseup\", onEnd);\n        document.removeEventListener(\"contextmenu\", onEnd);\n        document.removeEventListener(\"mousemove\", mouseMove);\n      };\n    }\n  }, []);\n\n  return (\n    <canvas\n      ref={ref}\n      width={window.innerWidth}\n      height={window.innerHeight}\n      style={{ background: \"#000\" }}\n    />\n  );\n});\n"],"names":["getDistance","p1","p2","offsetX","Math","abs","offsetY","sqrt","speed","particleSea","defaultSea","i","window","innerWidth","j","innerHeight","push","task","drawPoint","ctx","point","beginPath","arc","PI","fillStyle","fill","closePath","drawRepelPoint","temp","concat","forEach","p","target","distance","k","angle","atan","s","diff","dX","cos","dY","sin","d","awayDistance","movePoint","_ref","_ref2","_slicedToArray","x","y","_temp$i","m","n","radius","clearPoint","drawRepel","cancelAnimationFrame","requestAnimationFrame","memo","ref","useRef","useEffect","current","getContext","drawSea","isStart","onStart","onEnd","Infinity","draw","touchStart","e","preventDefault","targetTouches","clientX","clientY","mouseStart","touchMove","mouseMove","document","addEventListener","passive","removeEventListener","_jsx","width","height","style","background"],"sourceRoot":""}