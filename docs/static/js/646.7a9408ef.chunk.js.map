{"version":3,"file":"static/js/646.7a9408ef.chunk.js","mappings":"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","sources":["pages/demo2/drawSea.ts","utils/distance.ts","pages/demo2/index.tsx"],"sourcesContent":["import { getDistance } from \"../../utils/distance\";\n\nconst radius = 2, // 粒子半径大小\n  repelRadius = 100, // 排斥圈半径\n  speed = [0.01, 0.1], // 排斥速度\n  gridWith = 30; // 粒子间距\n\nconst particleSea: Point[] = [],\n  defaultSea: Point[] = [];\nfor (let i = radius; i < window.innerWidth; i += gridWith) {\n  for (let j = radius; j < window.innerHeight; j += gridWith) {\n    particleSea.push([i, j]);\n    defaultSea.push([i, j]);\n  }\n}\n\nconst drawPoint = (ctx: CanvasRenderingContext2D, point: Point) => {\n  ctx.beginPath();\n  ctx.arc(point[0], point[1], radius, 0, 2 * Math.PI);\n  ctx.fillStyle = \"#666\";\n  ctx.fill();\n  ctx.closePath();\n};\n\nconst clearPoint = (ctx: CanvasRenderingContext2D, point: Point) => {\n  ctx.beginPath();\n  ctx.arc(point[0], point[1], radius + 1, 0, 2 * Math.PI);\n  ctx.fillStyle = \"#000\";\n  ctx.fill();\n  ctx.closePath();\n};\n\nconst movePoint = (target: Point, p: Point, i: number) => {\n  const distance = getDistance(target, p);\n\n  // 防止边缘抖动，设置一定阈值，应该怎么计算目前不知道，试出来的\n  if (distance - repelRadius < 15) {\n    const k = (target[1] - p[1]) / (target[0] - p[0]);\n    const angle = Math.atan(k);\n    const s = speed[1] - ((speed[1] - speed[0]) * distance) / repelRadius;\n    const diff = target[0] - p[0] > 0 ? -distance * s : distance * s;\n    const dX = diff * Math.cos(angle);\n    const dY = diff * Math.sin(angle);\n    particleSea[i] = [p[0] + dX, p[1] + dY];\n  } else {\n    const d = defaultSea[i];\n    if (p[0] !== d[0] || p[1] !== d[1]) {\n      const awayDistance = getDistance(d, p);\n\n      const k = (d[1] - p[1]) / (d[0] - p[0]);\n      const angle = Math.atan(k);\n      const s = speed[0] + ((speed[1] - speed[0]) * awayDistance) / repelRadius;\n      const diff = d[0] - p[0] > 0 ? awayDistance * s : -awayDistance * s;\n      const dX = diff * Math.cos(angle);\n      const dY = diff * Math.sin(angle);\n      particleSea[i] = [p[0] + dX, p[1] + dY];\n    }\n  }\n};\n\nexport const drawRepelPoint = (ctx: CanvasRenderingContext2D, point: Point) => {\n  const temp = [...particleSea];\n\n  particleSea.forEach((p, i) => {\n    movePoint(point, p, i);\n  });\n\n  particleSea.forEach(([x, y], i) => {\n    const [m, n] = temp[i];\n    if (x !== m || y !== n) {\n      clearPoint(ctx, [m, n]);\n      drawPoint(ctx, [x, y]);\n    }\n  });\n};\n\nlet task: number;\nexport const drawRepel = (ctx: CanvasRenderingContext2D, point: Point) => {\n  drawRepelPoint(ctx, point);\n  cancelAnimationFrame(task);\n\n  task = requestAnimationFrame(() => {\n    drawRepel(ctx, point);\n  });\n};\n\nexport const drawSea = (ctx: CanvasRenderingContext2D) => {\n  defaultSea.forEach((point) => drawPoint(ctx, point));\n};\n","export const getDistance = (p1: Point, p2: Point) => {\n  const offsetX = Math.abs(p1[0] - p2[0]),\n    offsetY = Math.abs(p1[1] - p2[1]);\n  return Math.sqrt(offsetX * offsetX + offsetY * offsetY);\n};","import { memo, useEffect, useRef } from \"react\";\n\nimport { drawRepel, drawSea } from \"./drawSea\";\n\nexport default memo(() => {\n  const ref = useRef<HTMLCanvasElement>(null);\n\n  useEffect(() => {\n    if (ref.current) {\n      const ctx = ref.current.getContext(\"2d\");\n\n      ctx && drawSea(ctx);\n\n      let isStart = false;\n\n      const onStart = (p: Point) => {\n        isStart = true;\n        ctx && drawRepel(ctx, p);\n      };\n\n      const onEnd = () => {\n        isStart = false;\n        ctx && drawRepel(ctx, [Infinity, Infinity]);\n      };\n\n      const draw = (p: Point) => {\n        if (isStart && ctx) {\n          drawRepel(ctx, p);\n        }\n      };\n\n      const touchStart = (e: TouchEvent) => {\n        e.preventDefault();\n        onStart([e.targetTouches[0].clientX, e.targetTouches[0].clientY]);\n      };\n\n      const mouseStart = (e: MouseEvent) => {\n        onStart([e.clientX, e.clientY]);\n      };\n\n      const touchMove = (e: TouchEvent) => {\n        e.preventDefault();\n        draw([e.targetTouches[0].clientX, e.targetTouches[0].clientY]);\n      };\n\n      const mouseMove = (e: MouseEvent) => {\n        draw([e.clientX, e.clientY]);\n      };\n\n      document.addEventListener(\"touchstart\", touchStart, { passive: false });\n      document.addEventListener(\"touchmove\", touchMove, { passive: false });\n      document.addEventListener(\"touchend\", onEnd);\n      document.addEventListener(\"mousedown\", mouseStart);\n      document.addEventListener(\"mouseup\", onEnd);\n      document.addEventListener(\"mousemove\", mouseMove);\n      document.addEventListener(\"contextmenu\", onEnd);\n\n      return () => {\n        document.removeEventListener(\"touchstart\", touchStart);\n        document.removeEventListener(\"touchmove\", touchMove);\n        document.removeEventListener(\"touchend\", onEnd);\n        document.removeEventListener(\"mousedown\", mouseStart);\n        document.removeEventListener(\"mouseup\", onEnd);\n        document.removeEventListener(\"contextmenu\", onEnd);\n        document.removeEventListener(\"mousemove\", mouseMove);\n      };\n    }\n  }, []);\n\n  return (\n    <canvas\n      ref={ref}\n      width={window.innerWidth}\n      height={window.innerHeight}\n      style={{ background: \"#000\" }}\n    />\n  );\n});\n"],"names":["getDistance","p1","p2","offsetX","Math","abs","offsetY","sqrt","speed","particleSea","defaultSea","i","window","innerWidth","j","innerHeight","push","task","drawPoint","ctx","point","beginPath","arc","PI","fillStyle","fill","closePath","drawRepelPoint","temp","forEach","p","target","distance","k","angle","atan","s","diff","dX","cos","dY","sin","d","awayDistance","movePoint","x","y","m","n","radius","clearPoint","drawRepel","cancelAnimationFrame","requestAnimationFrame","memo","ref","useRef","useEffect","current","getContext","drawSea","isStart","onStart","onEnd","Infinity","draw","touchStart","e","preventDefault","targetTouches","clientX","clientY","mouseStart","touchMove","mouseMove","document","addEventListener","passive","removeEventListener","width","height","style","background"],"sourceRoot":""}